[{"title":"新年新气象：翻新陈旧的博客","url":"/2021/12-31-2021/12_31_新年新气象：翻新陈旧的博客/","content":"\n>本博客年久失修，为了显得好看一点，也为了重新写一些文章，特地从Jekyll换成了Hexo。\n\n当初部署成Jekyll完全是因为听信了GitHub的默认配置建议，等到我真正部署了才发现我根本折腾不明白Jekyll，选的主题也很难看。\n今日，我把博客生成工具换成了我更熟悉的Hexo，迁移步骤如下。\n\n### 文章迁移\n\n首先，迁移的核心是文章。\n两种框架存放文章的位置有所不同。Jekyll是直接放在`@/posts`里，Hexo则是放在`@/source/_posts`里。\n其次应该是文章所用到的图片，不过我的博客目前还没有图，因此这步先忽略。\n\n### 设置Hexo主题\n\n本博客目前所选主题是[aircloud](https://github.com/aircloud/hexo-theme-aircloud)，简洁、功能齐全。\n为了后续部署的自动化，主题的下载使用git指令添加该主题为submodule。\n```sh\ngit submodule add https://github.com/aircloud/hexo-theme-aircloud ./themes/hexo-theme-aircloud\n```\n\n`_config.yml`是一些全局选项，两种框架大同小异。\nHexo的主题设定也写在这个文件里。\n详细配置请参考[Aircloud作者的demo](https://github.com/aircloud/hexo-aircloud-blog/blob/master/_config.yml)。\n\nAircloud可以显示头像，但我懒得上传图片。\n因此，我选择从Gravatar获取头像。\nGravatar的头像API的URI为`https://gravatar.com/avatar/EMAIL_HASH`。\n其中`EMIAL_HASH`为你在Gravatar上登记的邮箱的md5哈希值，可以通过如下指令生成：\n```sh\nprintf \"your-email@example.com\" | md5sum | awk '{print $1}'\n```\n\n### 最后的工作\n\n或许你注意到了，使用hexo生成博客的时候需要下载nodejs依赖，也就是`@/node_module`文件夹下的内容。\n在此之前，我们需要先编辑`@/.gitignore`文件，将`node_module`加入到忽略列表里。\n我从其他Hexo项目里复制了`package*.json`，然后运行`npm install`。\n\n自此，博客的配置就完毕了。\n\n### 附加步骤：GitHub Actions\n\n首先根据[Hexo官网的指南](https://hexo.io/docs/github-pages.html)进行设置，然后在适当的位置加入如下代码以安装主题：\n\n```yml\n- name: Install Theme\n  run: |\n    git submodule init\n    git submodule update --remote\n```\n\nAll done.\n","tags":["js","hexo"],"categories":["折腾"]},{"title":"基于Laravel的应用在服务端的部署","url":"/2021/02-02-2021/02_02_基于Laravel的应用在服务端的部署/","content":"\n>一个已经去世的应用重获新生，需要在服务端重新部署，因此就有了这篇文章。\n\n### 服务器环境\n\n- 系统：Ubuntu 20.04\n- CPU：4核 Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz\n- 内存：8G\n\n### 前置工作\n\nUbuntu 20.04只有php7.2，但我至少需要php7.4，因此先更新php源：\n\n```sh\nsudo add-apt-repository ppa:ondrej/php\n```\n\n然后安装HTTP服务器、Mysql、PHP、以及Laravel的一些依赖。\n```sh\nsudo apt install apache2 \\\n    mysql-server \\\n    php7.4 \\\n    libapache2-mod-php7.4 \\\n    php7.4-mysql \\\n    php7.4-opcache php7.4-mbstring \\\n    php-ssh2 php-tokenizer \\\n    php7.4-xml php7.4-json \\\n    php7.4-bcmath php7.4-zip \\\n    php7.4-curl php7.4-gd\n```\n\n将项目文件解压到`/var/www/`目录下\n```sh\nunzip finelyteam.zip\nsudo mv finelyteam /var/www/finelyteam\n```\n\n### 配置Apache\n#### 配置VirtualHost\n\n配置Apache网站文件`/etc/apache2/sites-available/finelyteam.conf`：\n```apache\n<VirtualHost *:80>\n\tServerAdmin root@localhost\n\tServerName dev.finely-team.com\n\tDocumentRoot /var/www/finelyteam/public\n\n\tErrorLog ${APACHE_LOG_DIR}/error.finely-team.log\n\tCustomLog ${APACHE_LOG_DIR}/access.finely-team.log combined\n</VirtualHost>\n```\n\n#### 启用VirtualHost\n\n```sh\nsudo a2ensite finelyteam.conf\n```\n\n#### 启用Apache模块\n\n```sh\nsudo a2enmod php7.4 ssl rewrite\n```\n\n#### 编辑apache全局设置\n\n编辑文件`/etc/apache2/apache2.conf`，注意`AllowOverride`选项变更为`all`\n\n```apache\n<Directory /var/www/>\n\tOptions Indexes FollowSymLinks\n\tAllowOverride all\n\tRequire all granted\n</Directory>\n```\n\n#### 重启 Apache 服务\n\n```\nsudo service apache2 restart\n```\n\n### 配置MySQL\n\n#### 生成管理员用户\n\n为了让PHP访问数据库，我们需要生成一个MySQL用户。\nMySQL初始只允许root免密登录。\n这是不安全的，而且Laravel应用无法使用这个账户。\n\n在MySQL cli里执行以下指令以生成用户并赋予所有权限。\n\n```sql\nCREATE USER laravel_admin@localhost IDENTIFIED BY 'password';\nGRANT ALL PRIVILEGES ON * . * TO laravel_admin@localhost;\nFLUSH PRIVILEGES;\n```\n\n#### 添加数据库\n\n```sql\nCREATE DATABASE finelyteam;\n```\n\n### 配置PostgreSQL\n\n#### 安装PHP驱动\n\n如果你安装的不是mysql而是pgsql，则需要安装php驱动：\n```sh\nsudo apt install php7.4-pgsql\n```\n\n进入cli时不能使用root用户，只能使用特定用户：`postgres`\n\n```\nsu postgres\npsql\n```\n\n#### 创建管理员用户\n\n```\ncreate user laravel_admin superuser password '123456';\n```\n\n#### 创建数据库\n\n```sql\nCREATE DATABASE laravel;\n```\n\n### 配置PHP\n\n#### 安装Composer\n\nComposer是PHP的包管理工具。\n\n```sh\nsudo apt-get remove composer # 不要使用 Ubuntu 库中的Composer\ncd # 回家\ncurl -sS https://getcomposer.org/installer | php\nmv ./composer.phar /usr/local/bin/composer\n# 如果提示 'Failed to decode zlib stream' 则执行\n# sudo apt install zlib\n```\n\n#### Composer换源与安装\n\n```sh\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ # 切换国内 Composer 镜像\ncd /var/www/finelyteam\ncomposer update # 自动安装\n```\n\n### 配置Laravel\n\n#### DOT ENV\n\n现在来到Laravel项目的文件夹下，先生成`.env`文件。\n\n```sh\ncd /var/www/finelyteam\nmv .env.example .env\nphp artisan key:generate # 生成 APP KEY\n```\n\n如果之前使用的是pgsql，则需要修改数据库连接，尤其是端口：\n\n```env\nDB_CONNECTION=pgsql\nDB_HOST=127.0.0.1\nDB_PORT=5432\nDB_DATABASE=laravel\nDB_USERNAME=laravel_admin\n```\n\n#### 目录权限\n\n为以下目录分配权限以保证访问正常。\n\n```sh\nsudo chmod -R 777 public storage bootstrap/cache\n```\n\n#### 数据库迁移\n\n```sh\nphp artisan migrate --seed\n```\n\nAll done.\n","tags":["sql","coding"],"categories":["折腾"]},{"title":"How to Make an Axel Win32 Build","url":"/2020/10-02-2020/10_02_axel-win32-build/","content":"\n>This page is for those who want to use Axel on windows. I  was on progress with the win32 build of Axel some months ago. But now it is stalled, as I am busy. Anyway, this article ought to be useful for those who want to make a latest build even in the future.\n\n### Preparation\n\n#### Download and compile MinGW\nFor example, on Ubuntu:\n```shell\nsudo apt install mingw-w64\n```\n#### Download and compile OpenSSL against MinGW\n[Reference](https://marc.xn--wckerlin-0za.ch/computer/cross-compile-openssl-for-windows-on-linux)\n\nFirst, download the 1.1.1 release on Github (or the latest, it depends on you).\nBefore making, 3 lines should be added to the file `include/openssl/x509v3.h`, just after the line of `#define HEADER_X509V3_H`:\n```c\n#ifdef X509_NAME\n#undef X509_NAME\n#endif\n```\nAfter that, run compile commands:\n```shell\ncd /path/to/openssl\n./Configure mingw shared --cross-compile-prefix=x86_64-w64-mingw32- --prefix=/path/to/installation\nmake -j4 && make install\n```\n\nBy default, OpenSSL will be installed to `/usr/local`, and usually there is a necessity to configure the installation path with `--prefix` like `/home/jason/OpenSSL-mingw64`.\n\n### Build Axel\nAutotools are required if you are building Axel from the master branch\nFor more information, please check the [Axel installation guide](https://github.com/axel-download-accelerator/axel#building-from-source).\n\nIf you are building from a release tarball, the command could be like this:\n```shell\n./configure --host=x86_64-w64-mingw32 --with-ssl=/path/to/OpenSSL\nmake && sudo make install\n```\nAnd now, Axel is built and insatlled to `/usr/local/bin`.","tags":["C","axel"],"categories":["折腾"]},{"title":"Bash中for循环的四种写法","url":"/2020/05-19-2020/05_20_bash中for循环的四种写法/","content":"\n> 有一回对我说道，“你学过编程么？”我略略点一点头。他说，“学过编程，……我便考你一考。bash的for循环，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。zsc等了许久，很恳切的说道，“不能写罢？……我教给你，记着!这些写法应该记着。将来运维的时候，写脚本要用。”我暗想我和运维的等级还很远呢，而且我们运维大佬也从不写什么bash，都是用python或者perl的；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是和C语言几乎一样么？”zsc显出极高兴的样子，将两个指头的长指甲敲着柜台，点头说，“对呀对呀!……bash的for循环有四样写法，你知道么？\n\n#### C语言风格\n```bash\nnum=10\nfor ((i = 0; i < $num; i++)); do\n    echo $i\ndone\n```\n\n#### Buildin枚举\n```bash\nnum=10\nfor i in {1..10}; do\n    echo $i\ndone\n```\n\n#### 迭代器遍历指令输出\n```bash\nnum=10\nfor i in $(seq 1 $num); do\n    echo $i\ndone\n```\n\n#### 迭代器遍历正则匹配\n```bash\nfor file in ./*; do\n    echo $file\ndone\n```","tags":["shell"],"categories":["小技巧"]},{"title":"记一次sql优化","url":"/2020/04-28-2020/04_28_记一次sql优化/","content":"\n>今天筛选爬虫失败的任务的时候，要求出一个子集的补集，使用not in语句效率太慢，后来通过left join实现了性能优化。\n\n#### 简朴的想法\n\n今有一爬虫，每次从`tasks`中取出任务，将结果存储在`materials`数据表中，在完成时将`tasks`对应`finished`列的值从0变成1.\n有时出现非HTTP错误时虽然`finished`列的值是1，但是任务并没有完成，也就是说`materials`表里并没有对应数据。\n\n为了找出所有没有正常完成的任务，现构造sql语句如下：\n```sql\nselect\n    *\nfrom\n    tasks\nwhere\n    id not in (\n        select\n            a.id\n        from\n            tasks a\n            join materials b on a.url = b.url\n    );\n```\n不那么显然地，这句话执行巨慢，3秒没有反应就被我强行终止了（ctrl + c）。\n有趣的是，如果上面的`where not in`改为`where in`语句，效率是正常的。\n具体的原理感兴趣者可以bing一下。\n\n为了解决这个问题，稍微查阅以下资料，我决定使用left join来代替原本的`where not in`语句。（mysql并没有except语句）\n```sql\nselect\n    *\nfrom\n    tasks\n    left join (\n        select\n            *\n        from\n            tasks a\n            join materials b on a.url = b.url\n    ) c on tasks.id = c.id\nwhere\n    c.url is NULL\n```\n不幸的是，执行依旧很慢...\n通过一番简单的分析，推测子语句会执行很多次，所以拖慢了执行速度，原因和`where not in`是一样的。\n\n于是，稍微变化一下了的最终方案如下：\n```sql\n-- 创建临时表，用来存储已经完成的任务\ncreate temporary table `tmp` (\n    `id` int NOT NULL,\n    `url` varchar(256) NOT NULL,\n    `finished` tinyint(1) DEFAULT '0',\n    `created_at` datetime DEFAULT NULL,\n    `updated_at` datetime DEFAULT NULL,\n    `deleted_at` datetime DEFAULT NULL,\n    PRIMARY KEY (`id`),\n    KEY `idx_tasks_deleted_at` (`deleted_at`)\n);\n\ninsert into\n    tmp\nselect\n    distinct a.*\nfrom\n    tasks a\n    join materials b on a.url = b.url;\n\n-- 创建临时表，存储未完成的task的id\ncreate temporary table `list` (`id` int, PRIMARY KEY(`id`));\n\ninsert into\n    list\nselect\n    tasks.id\nfrom\n    tasks\n    left join tmp on tasks.id = tmp.id\nwhere\n    tmp.id is NULL;\n\n-- 这步的子语句不能包含tasks表，这也是上一语句的存在意义\nupdate\n    tasks\nset\n    finished = 0\nwhere\n    id in (\n        select\n            id\n        from\n            list\n    );\n```","tags":["sql"],"categories":["优化"]},{"title":"记一次GMAIL无法提醒邮件信息的排查","url":"/2020/04-10-2020/04_10_记一次gmail无法提醒邮件信息的排查/","content":"\n>最近发现手机上GMAIL总是不提醒新的邮件，并且消息都变成了已读。这使得我总是收不到来自github和gitlab的消息通知。这个问题很早就出现过了，最近出现得十分频繁，今天我把它解决了。\n\n#### 邮箱服务器与客户端\n首先我思考了以下我最近关于邮件做了哪些设置，邮件服务器是我自己配的，客户端则有三个：\n- Ubuntu上的`mutt`+`fetchmail`+`maildrop`\n- Andriod上的`GMAIL`\n- Microsoft Flow\n\n其中最后一个是手机上一个提供简易自动化任务的软件，一个月前我设置过检测GMAIL邮件并弹出提示，不过因为不好用就把任务删除了。\n再次检查确定没有任务读取GMAIL，虽然它看起来最可疑，但却是最先被排除的。\n其次思考GMAIL，GMAIL可能会收到消息但不提醒，但是不会收到消息直接变成已读，所以先保留。\n最后就是fetchmail的检查了。\n\n#### cron任务与fetchmail\n以man page的自我介绍来说，`fetchmail`  is  a mail-retrieval and forwarding utility.\n\n我用它来拉取邮件列表，cron任务如下所示\n```bash\n*/5 * * * * fetchmail\n```\n\n然后我恍然大悟，原本的cron任务是每15分钟一次，现在被我改成了5分钟一次，自此我的GMAIL才无法正常获取邮件列表。\n\n#### 真相大白\n原来问题处在fetchmail身上！\nGMAIL能够设置的最短拉取邮件列表的时间就是15分钟，以往两者的时间间隔相等，所以GMAIL有一定的的概率先拉取邮件，但是当fetchmail查询间隔变为5分钟之后，GMAIL就没有一丝机会获取到新的邮件了。\n\n#### 问题解决\n刚才的讨论推测出了问题的起因，但是没有涉及到问题的本质，那就是，为什么fetchmail拉取邮件之后，邮件被标记成已读？\n通过查阅资料得知\n- fetchmail标记信息为已读的问题自古就已经存在\n- 有的人没有办法，有的人自己写了插件\n\n我怎么办呢，我端详我的fetchmail配置文件，在里面找到一个关键字，`imap`\nfile: ~/.fetchmailrc\n```bash\ndefaults\nmda \"/usr/bin/maildrop\"\n\npoll imap.jason233.top\nproto imap\nport 143\nuser jason@jason233.top\npassword ******\nmimedecode\nkeep\n```\n\n众所周知，IMAP和POP3都是邮件服务器常用的协议，对于两者的详细区别不再赘述。\n通俗来讲，POP3是“只读”的，IMAP是“同步修改”的。\n所以，把IMAP换成POP3就可以了。\n\n只要过了这一波测试...还不行。\n不过小场面，不要慌，继续查阅资料，添加一个UIDL参数就可以了。\n\n```bash\ndefaults\nmda \"/usr/bin/maildrop\"\n\npoll pop3.jason233.top\nproto po3\nport 110\nuidl\nuser jason@jason233.top\npassword ******\nmimedecode\nkeep\n```\n\n#### 进阶crontab\n通过cron任务发桌面提醒我有新邮件。\n\ncron:\n```bash\n*/5 * * * * /home/jason/.local/bin/fetchmail-and-notify\n```\n\nfile: fetchmail-and-notify\n```bash\n#!/bin/bash\n\n# env for notify-send\nexport DISPLAY=:0\nexport DBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/user/1000/bus\"\n\n# config\nMAIL_INBOX=~/mail/personal/jason/INBOX\nLOG_FILE=~/mail/log/notify.log\nTIMESTAMP_FILE=~/mail/last_check\n\n# open log stream (append)\nexec 3>>$LOG_FILE\nwrite_log() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] $1\" >&3\n}\n\n# fetch mail\nfetchmail\n\nlast=$(cat $TIMESTAMP_FILE)\necho $(date +%s) >$TIMESTAMP_FILE\nwrite_log \"Updated timestamp cache.\"\n\nmodified=$(stat -c '%Y' \"$MAIL_INBOX\")\n\n# TODO use inotify instead\n# compare timestamp\nif [ $((modified - last)) -gt 10 ]; then\n    # show notification\n    notify-send \"mail\" \"You have new mail.\" -i mutt\n    write_log \"Sent a notify.\"\nfi\n\n# close log stream\nexec 3>&-\n```\n\n**P.S.** 关于邮箱服务器的配置\n鉴于我的阿里云服务器25端口（SMTP）封禁，正常的邮箱设置也就是通过邮件服务器发送邮件给其他人是行不通的。\n所以我就在本机上又搭了一个邮件服务器，没错我又装了一个Postfix。","tags":["shell","fetchmail","cron"],"categories":["折腾"]},{"title":"记一次sql查询语句性能优化","url":"/2020/04-07-2020/04_07_记一次sql查询语句性能优化/","content":"\n>上周发现我写的一个项目，某两个API响应时间竟然长达6.5s，为了进行性能优化，我决定从sql语句的执行情况开始检查。\n\n因为使用了`Laravel`自带的ORM，所以要先看一下生成的sql语句，使用`Laravel`自带的`tinker`命令行工具，执行相关代码:\n```php\nDB::connection()->enableQueryLog();\nCourseRepository::whereHas('properties', function ($query) {\n    $query->where('user_id', 1);\n})->with(['properties' => function ($query) {\n    $query->where('user_id', 1);\n}])->get();\nDB::getQueryLog();\n```\n得到的执行结果如下所示：\n```php\n[\n     [\n       \"query\" => \"select * from `courses` where exists (select * from `course_properti\nes` where `courses`.`id` = `course_properties`.`course_id` and `user_id` = ? and `course_properties`.`deleted_at` is null) and `courses`.`deleted_at` is null\",\n       \"bindings\" => [\n         1,\n       ],\n       \"time\" => 6543.86,\n     ],\n   ]\n```\n毫无疑问地，这个sql查询占用了整个响应周期的绝大部分时间。\n分析sql语句，发现`where exists`子语句很有问题，对于每一个查询结果，都要进行一次`exists`与否的检查，所以时间复杂度是`n^2`。\n解决这个问题的方案有两个：\n1. 使用编程语言也就是php实现子语句部分的检查功能\n2. 使用`where in`子语句迭代主键id的方式代替`where exists`子语句\n\n在这里我选择的是第一个方案，因为我想了一会如何用`Laravel`自带的ORM组装这个语句，最终放弃了...\n此时也就体现出了重量级ORM的弊端：在组装sql语句的时候约束过多，复杂查询的实现方式繁琐。\n\n经过简单的优化，相关接口的执行时间由原先的6500ms缩减到200ms。","tags":["sql"],"categories":["优化"]}]