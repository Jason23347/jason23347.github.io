<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Simple Blog</title>
  
  
  <link href="https://jason23347.github.io/atom.xml" rel="self"/>
  
  <link href="https://jason23347.github.io/"/>
  <updated>2022-01-03T04:42:15.123Z</updated>
  <id>https://jason23347.github.io/</id>
  
  <author>
    <name>Jason23347</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新年新气象：翻新陈旧的博客</title>
    <link href="https://jason23347.github.io/2021/12-31-2021/12_31_%E6%96%B0%E5%B9%B4%E6%96%B0%E6%B0%94%E8%B1%A1%EF%BC%9A%E7%BF%BB%E6%96%B0%E9%99%88%E6%97%A7%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jason23347.github.io/2021/12-31-2021/12_31_%E6%96%B0%E5%B9%B4%E6%96%B0%E6%B0%94%E8%B1%A1%EF%BC%9A%E7%BF%BB%E6%96%B0%E9%99%88%E6%97%A7%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-31T13:15:06.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客年久失修，为了显得好看一点，也为了重新写一些文章，特地从Jekyll换成了Hexo。</p></blockquote><p>当初部署成Jekyll完全是因为听信了GitHub的默认配置建议，等到我真正部署了才发现我根本折腾不明白Jekyll，选的主题也很难看。今日，我把博客生成工具换成了我更熟悉的Hexo，迁移步骤如下。</p><h3 id="文章迁移">文章迁移</h3><p>首先，迁移的核心是文章。两种框架存放文章的位置有所不同。Jekyll是直接放在<code>@/posts</code>里，Hexo则是放在<code>@/source/_posts</code>里。其次应该是文章所用到的图片，不过我的博客目前还没有图，因此这步先忽略。</p><h3 id="设置hexo主题">设置Hexo主题</h3><p>本博客目前所选主题是<a href="https://github.com/aircloud/hexo-theme-aircloud">aircloud</a>，简洁、功能齐全。为了后续部署的自动化，主题的下载使用git指令添加该主题为submodule。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/aircloud/hexo-theme-aircloud ./themes/hexo-theme-aircloud</span><br></pre></td></tr></table></figure></p><p><code>_config.yml</code>是一些全局选项，两种框架大同小异。 Hexo的主题设定也写在这个文件里。详细配置请参考<a href="https://github.com/aircloud/hexo-aircloud-blog/blob/master/_config.yml">Aircloud作者的demo</a>。</p><p>Aircloud可以显示头像，但我懒得上传图片。因此，我选择从Gravatar获取头像。 Gravatar的头像API的URI为<code>https://gravatar.com/avatar/EMAIL_HASH</code>。其中<code>EMIAL_HASH</code>为你在Gravatar上登记的邮箱的md5哈希值，可以通过如下指令生成： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;your-email@example.com&quot;</span> | md5sum | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p><h3 id="最后的工作">最后的工作</h3><p>或许你注意到了，使用hexo生成博客的时候需要下载nodejs依赖，也就是<code>@/node_module</code>文件夹下的内容。在此之前，我们需要先编辑<code>@/.gitignore</code>文件，将<code>node_module</code>加入到忽略列表里。我从其他Hexo项目里复制了<code>package*.json</code>，然后运行<code>npm install</code>。</p><p>自此，博客的配置就完毕了。</p><h3 id="附加步骤github-actions">附加步骤：GitHub Actions</h3><p>首先根据<a href="https://hexo.io/docs/github-pages.html">Hexo官网的指南</a>进行设置，然后在适当的位置加入如下代码以安装主题：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Theme</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">git</span> <span class="string">submodule</span> <span class="string">init</span></span><br><span class="line">    <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--remote</span></span><br></pre></td></tr></table></figure><p>All done.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客年久失修，为了显得好看一点，也为了重新写一些文章，特地从Jekyll换成了Hexo。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当初部署成Jekyll完全是因为听信了GitHub的默认配置建议，等到我真正部署了才发现我根本折腾不明白Jekyl</summary>
      
    
    
    
    <category term="折腾" scheme="https://jason23347.github.io/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="js" scheme="https://jason23347.github.io/tags/js/"/>
    
    <category term="hexo" scheme="https://jason23347.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>基于Laravel的应用在服务端的部署</title>
    <link href="https://jason23347.github.io/2021/02-02-2021/02_02_%E5%9F%BA%E4%BA%8ELaravel%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <id>https://jason23347.github.io/2021/02-02-2021/02_02_%E5%9F%BA%E4%BA%8ELaravel%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%83%A8%E7%BD%B2/</id>
    <published>2021-02-02T00:21:14.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个已经去世的应用重获新生，需要在服务端重新部署，因此就有了这篇文章。</p></blockquote><h3 id="服务器环境">服务器环境</h3><ul><li>系统：Ubuntu 20.04</li><li>CPU：4核 Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz</li><li>内存：8G</li></ul><h3 id="前置工作">前置工作</h3><p>Ubuntu 20.04只有php7.2，但我至少需要php7.4，因此先更新php源：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure><p>然后安装HTTP服务器、Mysql、PHP、以及Laravel的一些依赖。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install apache2 \</span><br><span class="line">    mysql-server \</span><br><span class="line">    php7.4 \</span><br><span class="line">    libapache2-mod-php7.4 \</span><br><span class="line">    php7.4-mysql \</span><br><span class="line">    php7.4-opcache php7.4-mbstring \</span><br><span class="line">    php-ssh2 php-tokenizer \</span><br><span class="line">    php7.4-xml php7.4-json \</span><br><span class="line">    php7.4-bcmath php7.4-zip \</span><br><span class="line">    php7.4-curl php7.4-gd</span><br></pre></td></tr></table></figure></p><p>将项目文件解压到<code>/var/www/</code>目录下 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip finelyteam.zip</span><br><span class="line">sudo mv finelyteam /var/www/finelyteam</span><br></pre></td></tr></table></figure></p><h3 id="配置apache">配置Apache</h3><h4 id="配置virtualhost">配置VirtualHost</h4><p>配置Apache网站文件<code>/etc/apache2/sites-available/finelyteam.conf</code>： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;VirtualHost *<span class="number">:80</span>&gt;</span></span><br><span class="line"><span class="attribute">ServerAdmin</span> root@localhost</span><br><span class="line"><span class="attribute"><span class="nomarkup">ServerName</span></span> dev.finely-team.com</span><br><span class="line"><span class="attribute"><span class="nomarkup">DocumentRoot</span></span> /var/www/finelyteam/public</span><br><span class="line"></span><br><span class="line"><span class="attribute">ErrorLog</span> <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.finely-team.log</span><br><span class="line"><span class="attribute">CustomLog</span> <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.finely-team.log combined</span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="启用virtualhost">启用VirtualHost</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo a2ensite finelyteam.conf</span><br></pre></td></tr></table></figure><h4 id="启用apache模块">启用Apache模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo a2enmod php7.4 ssl rewrite</span><br></pre></td></tr></table></figure><h4 id="编辑apache全局设置">编辑apache全局设置</h4><p>编辑文件<code>/etc/apache2/apache2.conf</code>，注意<code>AllowOverride</code>选项变更为<code>all</code></p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">Options</span></span> Indexes FollowSymLinks</span><br><span class="line"><span class="attribute">AllowOverride</span> <span class="literal">all</span></span><br><span class="line"><span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><h4 id="重启-apache-服务">重启 Apache 服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><h3 id="配置mysql">配置MySQL</h3><h4 id="生成管理员用户">生成管理员用户</h4><p>为了让PHP访问数据库，我们需要生成一个MySQL用户。 MySQL初始只允许root免密登录。这是不安全的，而且Laravel应用无法使用这个账户。</p><p>在MySQL cli里执行以下指令以生成用户并赋予所有权限。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> laravel_admin<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span> . <span class="operator">*</span> <span class="keyword">TO</span> laravel_admin<span class="variable">@localhost</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h4 id="添加数据库">添加数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE finelyteam;</span><br></pre></td></tr></table></figure><h3 id="配置postgresql">配置PostgreSQL</h3><h4 id="安装php驱动">安装PHP驱动</h4><p>如果你安装的不是mysql而是pgsql，则需要安装php驱动： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install php7.4-pgsql</span><br></pre></td></tr></table></figure></p><p>进入cli时不能使用root用户，只能使用特定用户：<code>postgres</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su postgres</span><br><span class="line">psql</span><br></pre></td></tr></table></figure><h4 id="创建管理员用户">创建管理员用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user laravel_admin superuser password &#39;123456&#39;;</span><br></pre></td></tr></table></figure><h4 id="创建数据库">创建数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE laravel;</span><br></pre></td></tr></table></figure><h3 id="配置php">配置PHP</h3><h4 id="安装composer">安装Composer</h4><p>Composer是PHP的包管理工具。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove composer <span class="comment"># 不要使用 Ubuntu 库中的Composer</span></span><br><span class="line"><span class="built_in">cd</span> <span class="comment"># 回家</span></span><br><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv ./composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br><span class="line"><span class="comment"># 如果提示 &#x27;Failed to decode zlib stream&#x27; 则执行</span></span><br><span class="line"><span class="comment"># sudo apt install zlib</span></span><br></pre></td></tr></table></figure><h4 id="composer换源与安装">Composer换源与安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ <span class="comment"># 切换国内 Composer 镜像</span></span><br><span class="line"><span class="built_in">cd</span> /var/www/finelyteam</span><br><span class="line">composer update <span class="comment"># 自动安装</span></span><br></pre></td></tr></table></figure><h3 id="配置laravel">配置Laravel</h3><h4 id="dot-env">DOT ENV</h4><p>现在来到Laravel项目的文件夹下，先生成<code>.env</code>文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/finelyteam</span><br><span class="line">mv .env.example .env</span><br><span class="line">php artisan key:generate <span class="comment"># 生成 APP KEY</span></span><br></pre></td></tr></table></figure><p>如果之前使用的是pgsql，则需要修改数据库连接，尤其是端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_CONNECTION&#x3D;pgsql</span><br><span class="line">DB_HOST&#x3D;127.0.0.1</span><br><span class="line">DB_PORT&#x3D;5432</span><br><span class="line">DB_DATABASE&#x3D;laravel</span><br><span class="line">DB_USERNAME&#x3D;laravel_admin</span><br></pre></td></tr></table></figure><h4 id="目录权限">目录权限</h4><p>为以下目录分配权限以保证访问正常。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo chmod -R 777 public storage bootstrap/cache</span><br></pre></td></tr></table></figure><h4 id="数据库迁移">数据库迁移</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">php artisan migrate --seed</span><br></pre></td></tr></table></figure><p>All done.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个已经去世的应用重获新生，需要在服务端重新部署，因此就有了这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;服务器环境&quot;&gt;服务器环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系统：Ubuntu 20.04&lt;/li&gt;
&lt;li&gt;CPU：4核 Int</summary>
      
    
    
    
    <category term="折腾" scheme="https://jason23347.github.io/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="sql" scheme="https://jason23347.github.io/tags/sql/"/>
    
    <category term="coding" scheme="https://jason23347.github.io/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>How to Make an Axel Win32 Build</title>
    <link href="https://jason23347.github.io/2020/10-02-2020/10_02_axel-win32-build/"/>
    <id>https://jason23347.github.io/2020/10-02-2020/10_02_axel-win32-build/</id>
    <published>2020-10-02T01:06:07.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This post is for those who want to use Axel on windows. I was on progress with the win32 build of Axel some months ago. But now it is stalled, as I am busy. Anyway, this article ought to be useful for those who want to make a latest build even in the future.</p></blockquote><h3 id="preparation">Preparation</h3><h4 id="download-and-compile-mingw">Download and compile MinGW</h4><p>For example, on Ubuntu: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install mingw-w64</span><br></pre></td></tr></table></figure> #### Download and compile OpenSSL against MinGW</p><p><a href="https://marc.xn--wckerlin-0za.ch/computer/cross-compile-openssl-for-windows-on-linux">Reference</a></p><p>First, download the 1.1.1 release on Github (or the latest, it depends on you). Before making, 3 lines should be added to the file <code>include/openssl/x509v3.h</code>, just after the line of <code>#define HEADER_X509V3_H</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> X509_NAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X509_NAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>After that, run compile commands:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/openssl</span><br><span class="line">./Configure mingw shared --cross-compile-prefix=x86_64-w64-mingw32- --prefix=/path/to/installation</span><br><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>By default, OpenSSL will be installed to <code>/usr/local</code>, and usually there is a necessity to configure the installation path with <code>--prefix</code> like <code>/home/jason/OpenSSL-mingw64</code>.</p><h3 id="build-axel">Build Axel</h3><p>Autotools are required if you are building Axel from the master branch For more information, please check the <a href="https://github.com/axel-download-accelerator/axel#building-from-source">Axel installation guide</a>.</p><p>If you are building from a release tarball, the command could be like this:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --host=x86_64-w64-mingw32 --with-ssl=/path/to/OpenSSL</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>And now, Axel is built and installed to <code>/usr/local/bin</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;This post is for those who want to use Axel on windows. I was on progress with the win32 build of Axel some months ago. But </summary>
      
    
    
    
    <category term="折腾" scheme="https://jason23347.github.io/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="C" scheme="https://jason23347.github.io/tags/C/"/>
    
    <category term="axel" scheme="https://jason23347.github.io/tags/axel/"/>
    
  </entry>
  
  <entry>
    <title>Bash中for循环的四种写法</title>
    <link href="https://jason23347.github.io/2020/05-19-2020/05_20_bash%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>https://jason23347.github.io/2020/05-19-2020/05_20_bash%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%99%E6%B3%95/</id>
    <published>2020-05-19T18:15:17.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一回对我说道，“你学过编程么？”我略略点一点头。他说，“学过编程，……我便考你一考。bash的for循环，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。zsc等了许久，很恳切的说道，“不能写罢？……我教给你，记着!这些写法应该记着。将来运维的时候，写脚本要用。”我暗想我和运维的等级还很远呢，而且我们运维大佬也从不写什么bash，都是用python或者perl的；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是和C语言几乎一样么？”zsc显出极高兴的样子，将两个指头的长指甲敲着柜台，点头说，“对呀对呀!……bash的for循环有四样写法，你知道么？</p></blockquote><h4 id="c语言风格">C语言风格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num=10</span><br><span class="line"><span class="keyword">for</span> ((i = 0; i &lt; <span class="variable">$num</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="buildin枚举">Buildin枚举</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num=10</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="迭代器遍历指令输出">迭代器遍历指令输出</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num=10</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 <span class="variable">$num</span>); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="迭代器遍历正则匹配">迭代器遍历正则匹配</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> ./*; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有一回对我说道，“你学过编程么？”我略略点一点头。他说，“学过编程，……我便考你一考。bash的for循环，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。zsc等了许久，很恳切的说道，“不能写罢？……我教给你，记着!这些写法应该</summary>
      
    
    
    
    <category term="小技巧" scheme="https://jason23347.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="shell" scheme="https://jason23347.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>记一次sql优化</title>
    <link href="https://jason23347.github.io/2020/04-28-2020/04_28_%E8%AE%B0%E4%B8%80%E6%AC%A1sql%E4%BC%98%E5%8C%96/"/>
    <id>https://jason23347.github.io/2020/04-28-2020/04_28_%E8%AE%B0%E4%B8%80%E6%AC%A1sql%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-28T04:58:35.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天筛选爬虫失败的任务的时候，要求出一个子集的补集，使用not in语句效率太慢，后来通过left join实现了性能优化。</p></blockquote><h4 id="简朴的想法">简朴的想法</h4><p>今有一爬虫，每次从<code>tasks</code>中取出任务，将结果存储在<code>materials</code>数据表中，在完成时将<code>tasks</code>对应<code>finished</code>列的值从0变成1. 有时出现非HTTP错误时虽然<code>finished</code>列的值是1，但是任务并没有完成，也就是说<code>materials</code>表里并没有对应数据。</p><p>为了找出所有没有正常完成的任务，现构造sql语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    tasks</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            a.id</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">            tasks a</span><br><span class="line">            <span class="keyword">join</span> materials b <span class="keyword">on</span> a.url <span class="operator">=</span> b.url</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>不那么显然地，这句话执行巨慢，3秒没有反应就被我强行终止了（ctrl + c）。有趣的是，如果上面的<code>where not in</code>改为<code>where in</code>语句，效率是正常的。具体的原理感兴趣者可以bing一下。</p><p>为了解决这个问题，稍微查阅以下资料，我决定使用left join来代替原本的<code>where not in</code>语句。（mysql并没有except语句）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    tasks</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">            tasks a</span><br><span class="line">            <span class="keyword">join</span> materials b <span class="keyword">on</span> a.url <span class="operator">=</span> b.url</span><br><span class="line">    ) c <span class="keyword">on</span> tasks.id <span class="operator">=</span> c.id</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    c.url <span class="keyword">is</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>不幸的是，执行依旧很慢... 通过一番简单的分析，推测子语句会执行很多次，所以拖慢了执行速度，原因和<code>where not in</code>是一样的。</p><p>于是，稍微变化一下了的最终方案如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表，用来存储已经完成的任务</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> `tmp` (</span><br><span class="line">    `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `url` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `finished` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `created_at` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `updated_at` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `deleted_at` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_tasks_deleted_at` (`deleted_at`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">    tmp</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="keyword">distinct</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    tasks a</span><br><span class="line">    <span class="keyword">join</span> materials b <span class="keyword">on</span> a.url <span class="operator">=</span> b.url;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建临时表，存储未完成的task的id</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> `list` (`id` <span class="type">int</span>, <span class="keyword">PRIMARY</span> KEY(`id`));</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">    list</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    tasks.id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    tasks</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> tmp <span class="keyword">on</span> tasks.id <span class="operator">=</span> tmp.id</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    tmp.id <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这步的子语句不能包含tasks表，这也是上一语句的存在意义</span></span><br><span class="line">update</span><br><span class="line">    tasks</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">    finished <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            id</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">            list</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天筛选爬虫失败的任务的时候，要求出一个子集的补集，使用not in语句效率太慢，后来通过left join实现了性能优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;简朴的想法&quot;&gt;简朴的想法&lt;/h4&gt;
&lt;p&gt;今有一爬虫，每次从&lt;code</summary>
      
    
    
    
    <category term="优化" scheme="https://jason23347.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="sql" scheme="https://jason23347.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>记一次GMAIL无法提醒邮件信息的排查</title>
    <link href="https://jason23347.github.io/2020/04-10-2020/04_10_%E8%AE%B0%E4%B8%80%E6%AC%A1gmail%E6%97%A0%E6%B3%95%E6%8F%90%E9%86%92%E9%82%AE%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8E%92%E6%9F%A5/"/>
    <id>https://jason23347.github.io/2020/04-10-2020/04_10_%E8%AE%B0%E4%B8%80%E6%AC%A1gmail%E6%97%A0%E6%B3%95%E6%8F%90%E9%86%92%E9%82%AE%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8E%92%E6%9F%A5/</id>
    <published>2020-04-10T11:59:23.000Z</published>
    <updated>2022-01-03T04:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近发现手机上GMAIL总是不提醒新的邮件，并且消息都变成了已读。这使得我总是收不到来自github和gitlab的消息通知。这个问题很早就出现过了，最近出现得十分频繁，今天我把它解决了。</p></blockquote><h4 id="邮箱服务器与客户端">邮箱服务器与客户端</h4><p>首先我思考了以下我最近关于邮件做了哪些设置，邮件服务器是我自己配的，客户端则有三个：</p><ul><li>Ubuntu上的<code>mutt</code>+<code>fetchmail</code>+<code>maildrop</code></li><li>Andriod上的<code>GMAIL</code></li><li>Microsoft Flow</li></ul><p>其中最后一个是手机上一个提供简易自动化任务的软件，一个月前我设置过检测GMAIL邮件并弹出提示，不过因为不好用就把任务删除了。再次检查确定没有任务读取GMAIL，虽然它看起来最可疑，但却是最先被排除的。其次思考GMAIL，GMAIL可能会收到消息但不提醒，但是不会收到消息直接变成已读，所以先保留。最后就是fetchmail的检查了。</p><h4 id="cron任务与fetchmail">cron任务与fetchmail</h4><p>以man page的自我介绍来说，<code>fetchmail</code> is a mail-retrieval and forwarding utility.</p><p>我用它来拉取邮件列表，cron任务如下所示 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/5 * * * * fetchmail</span><br></pre></td></tr></table></figure></p><p>然后我恍然大悟，原本的cron任务是每15分钟一次，现在被我改成了5分钟一次，自此我的GMAIL才无法正常获取邮件列表。</p><h4 id="真相大白">真相大白</h4><p>原来问题处在fetchmail身上！ GMAIL能够设置的最短拉取邮件列表的时间就是15分钟，以往两者的时间间隔相等，所以GMAIL有一定的的概率先拉取邮件，但是当fetchmail查询间隔变为5分钟之后，GMAIL就没有一丝机会获取到新的邮件了。</p><h4 id="问题解决">问题解决</h4><p>刚才的讨论推测出了问题的起因，但是没有涉及到问题的本质，那就是，为什么fetchmail拉取邮件之后，邮件被标记成已读？通过查阅资料得知，</p><ul><li>fetchmail标记信息为已读的问题自古就已经存在</li><li>有的人没有办法，有的人自己写了插件</li></ul><p>我怎么办呢，我端详我的fetchmail配置文件，在里面找到一个关键字，<code>imap</code>。编辑<code>~/.fetchmailrc</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">mda &quot;&#x2F;usr&#x2F;bin&#x2F;maildrop&quot;</span><br><span class="line"></span><br><span class="line">poll imap.jason233.top</span><br><span class="line">proto imap</span><br><span class="line">port 143</span><br><span class="line">user jason@jason233.top</span><br><span class="line">password ******</span><br><span class="line">mimedecode</span><br><span class="line">keep</span><br></pre></td></tr></table></figure><p>众所周知，IMAP和POP3都是邮件服务器常用的协议，对于两者的详细区别不再赘述。通俗来讲，POP3是“只读”的，IMAP是“同步修改”的。所以，把IMAP换成POP3就可以了。</p><p>只要过了这一波测试...还不行。不过小场面，不要慌，继续查阅资料，添加一个UIDL参数就可以了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">mda <span class="string">&quot;/usr/bin/maildrop&quot;</span></span><br><span class="line"></span><br><span class="line">poll pop3.jason233.top</span><br><span class="line">proto po3</span><br><span class="line">port 110</span><br><span class="line">uidl</span><br><span class="line">user jason@jason233.top</span><br><span class="line">password ******</span><br><span class="line">mimedecode</span><br><span class="line">keep</span><br></pre></td></tr></table></figure><h4 id="进阶crontab">进阶crontab</h4><p>通过cron任务发桌面提醒我有新邮件。</p><p>cron: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/5 * * * * /home/jason/.<span class="built_in">local</span>/bin/fetchmail-and-notify</span><br></pre></td></tr></table></figure></p><p>编辑文件<code>fetchmail-and-notify</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># env for notify-send</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=:0</span><br><span class="line"><span class="built_in">export</span> DBUS_SESSION_BUS_ADDRESS=<span class="string">&quot;unix:path=/run/user/1000/bus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># config</span></span><br><span class="line">MAIL_INBOX=~/mail/personal/jason/INBOX</span><br><span class="line">LOG_FILE=~/mail/<span class="built_in">log</span>/notify.log</span><br><span class="line">TIMESTAMP_FILE=~/mail/last_check</span><br><span class="line"></span><br><span class="line"><span class="comment"># open log stream (append)</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&gt;<span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="function"><span class="title">write_log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>] <span class="variable">$1</span>&quot;</span> &gt;&amp;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch mail</span></span><br><span class="line">fetchmail</span><br><span class="line"></span><br><span class="line">last=$(cat <span class="variable">$TIMESTAMP_FILE</span>)</span><br><span class="line"><span class="built_in">echo</span> $(date +%s) &gt;<span class="variable">$TIMESTAMP_FILE</span></span><br><span class="line">write_log <span class="string">&quot;Updated timestamp cache.&quot;</span></span><br><span class="line"></span><br><span class="line">modified=$(<span class="built_in">stat</span> -c <span class="string">&#x27;%Y&#x27;</span> <span class="string">&quot;<span class="variable">$MAIL_INBOX</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO use inotify instead</span></span><br><span class="line"><span class="comment"># compare timestamp</span></span><br><span class="line"><span class="keyword">if</span> [ $((modified - last)) -gt 10 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># show notification</span></span><br><span class="line">    notify-send <span class="string">&quot;mail&quot;</span> <span class="string">&quot;You have new mail.&quot;</span> -i mutt</span><br><span class="line">    write_log <span class="string">&quot;Sent a notify.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># close log stream</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure><p><strong>P.S.</strong> 关于邮箱服务器的配置</p><p>鉴于我的阿里云服务器25端口（SMTP）封禁，正常的邮箱设置也就是通过邮件服务器发送邮件给其他人是行不通的。所以我就在本机上又搭了一个邮件服务器，没错我又装了一个Postfix。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近发现手机上GMAIL总是不提醒新的邮件，并且消息都变成了已读。这使得我总是收不到来自github和gitlab的消息通知。这个问题很早就出现过了，最近出现得十分频繁，今天我把它解决了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;邮箱服</summary>
      
    
    
    
    <category term="折腾" scheme="https://jason23347.github.io/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="shell" scheme="https://jason23347.github.io/tags/shell/"/>
    
    <category term="fetchmail" scheme="https://jason23347.github.io/tags/fetchmail/"/>
    
    <category term="cron" scheme="https://jason23347.github.io/tags/cron/"/>
    
  </entry>
  
  <entry>
    <title>记一次sql查询语句性能优化</title>
    <link href="https://jason23347.github.io/2020/04-07-2020/04_07_%E8%AE%B0%E4%B8%80%E6%AC%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://jason23347.github.io/2020/04-07-2020/04_07_%E8%AE%B0%E4%B8%80%E6%AC%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-07T09:14:39.000Z</published>
    <updated>2022-01-03T04:42:15.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上周发现我写的一个项目，某两个API响应时间竟然长达6.5s，为了进行性能优化，我决定从sql语句的执行情况开始检查。</p></blockquote><p>因为使用了<code>Laravel</code>自带的ORM，所以要先看一下生成的sql语句，使用<code>Laravel</code>自带的<code>tinker</code>命令行工具，执行相关代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">DB::connection()-&gt;enableQueryLog();</span><br><span class="line">CourseRepository::whereHas(<span class="string">&#x27;properties&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$query</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;where(<span class="string">&#x27;user_id&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)-&gt;with([<span class="string">&#x27;properties&#x27;</span> =&gt; <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$query</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;where(<span class="string">&#x27;user_id&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;])-&gt;get();</span><br><span class="line">DB::getQueryLog();</span><br></pre></td></tr></table></figure><p>得到的执行结果如下所示：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [</span><br><span class="line">       <span class="string">&quot;query&quot;</span> =&gt; <span class="string">&quot;select * from `courses` where exists (select * from `course_properti</span></span><br><span class="line"><span class="string">es` where `courses`.`id` = `course_properties`.`course_id` and `user_id` = ? and `course_properties`.`deleted_at` is null) and `courses`.`deleted_at` is null&quot;</span>,</span><br><span class="line">       <span class="string">&quot;bindings&quot;</span> =&gt; [</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">       ],</span><br><span class="line">       <span class="string">&quot;time&quot;</span> =&gt; <span class="number">6543.86</span>,</span><br><span class="line">     ],</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><p>毫无疑问地，这个sql查询占用了整个响应周期的绝大部分时间。分析sql语句，发现<code>where exists</code>子语句很有问题，对于每一个查询结果，都要进行一次<code>exists</code>与否的检查，所以时间复杂度是<code>n^2</code>。解决这个问题的方案有两个：</p><ol type="1"><li>使用编程语言也就是php实现子语句部分的检查功能</li><li>使用<code>where in</code>子语句迭代主键id的方式代替<code>where exists</code>子语句</li></ol><p>在这里我选择的是第一个方案，因为我想了一会如何用<code>Laravel</code>自带的ORM组装这个语句，最终放弃了... 此时也就体现出了重量级ORM的弊端：在组装sql语句的时候约束过多，复杂查询的实现方式繁琐。</p><p>经过简单的优化，相关接口的执行时间由原先的6500ms缩减到200ms。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上周发现我写的一个项目，某两个API响应时间竟然长达6.5s，为了进行性能优化，我决定从sql语句的执行情况开始检查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为使用了&lt;code&gt;Laravel&lt;/code&gt;自带的ORM，所以要先看一下生成的s</summary>
      
    
    
    
    <category term="优化" scheme="https://jason23347.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="sql" scheme="https://jason23347.github.io/tags/sql/"/>
    
  </entry>
  
</feed>
